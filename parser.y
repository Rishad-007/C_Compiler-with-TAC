%{
    /* ----------------------------------------
     * C DECLARATIONS SECTION
     * Contains header files, function declarations, and global variables
     * ---------------------------------------- */
    #include<stdio.h>
    #include<string.h>
    #include<stdlib.h>
    #include<ctype.h>
    #include"lex.yy.c"  /* Including the lexer output file */
    
    /* Function declarations for parser operations */
    void yyerror(const char *s);  /* Error handling function */
    int yylex();  /* Lexical analyzer function, automatically generated by flex */
    int yywrap();  /* Called when input is exhausted */
    
    /* Symbol table management functions */
    void add(char);  /* Add symbol to symbol table with specified type */
    void insert_type();  /* Insert type information into symbol table */
    int search(char *);  /* Search symbol table for identifier */
    
    /* Parse tree functions */
	void print_tree(struct node*);  /* Print the entire parse tree */
	void print_tree_util(struct node*, int);  /* Utility function for printing parse tree */
	void print_inorder(struct node *);  /* Print tree nodes in-order */
    
    /* Semantic analysis functions */
    void check_declaration(char *);  /* Check if variable is declared */
	void check_return_type(char *);  /* Check if return type matches function type */
	int check_types(char *, char *);  /* Check compatibility of types */
	char *get_type(char *);  /* Get type of a symbol */
	
	/* Parse tree construction */
	struct node* mknode(struct node *left, struct node *right, char *token);  /* Create a new parse tree node */

    /* ----------------------------------------
     * SYMBOL TABLE STRUCTURE
     * For tracking identifiers and their types
     * ---------------------------------------- */
    struct dataType {
        char * id_name;    /* Name of the identifier */
        char * data_type;  /* Data type (int, float, char, etc.) */
        char * type;       /* Symbol type (Variable, Function, etc.) */
        char * line_no;    /* Line number where declared */
	} symbol_table[40];    /* Symbol table with max 40 entries */

    /* ----------------------------------------
     * GLOBAL VARIABLES
     * ---------------------------------------- */
    int count=0;           /* Counter for symbol table entries */
    int q;                 /* Flag for symbol table search results */
	char type[10];         /* Current data type being processed */
    extern int countn;     /* Line counter from lexer */
	struct node *head;     /* Root node of the parse tree */
	int sem_errors=0;      /* Counter for semantic errors */
	int ic_idx=0;          /* Index for intermediate code array */
	int temp_var=0;        /* Counter for temporary variables */
	int label=0;           /* Counter for labels in intermediate code */
	int is_for=0;          /* Flag to mark for loop context */
	char buff[100];        /* Buffer for intermediate code generation */
	char errors[10][100];  /* Array to store error messages */
	
	/* List of reserved keywords */
	char reserved[10][10] = {"int", "float", "char", "void", "if", "else", "for", "main", "return", "include"};
	
	/* Array to store generated intermediate code */
	char icg[50][100];

    /* ----------------------------------------
     * PARSE TREE NODE STRUCTURE
     * Binary tree structure for AST representation
     * ---------------------------------------- */
	struct node { 
		struct node *left;  /* Left child node */
		struct node *right; /* Right child node */
		char *token;        /* Node value/token */
	};

%}

/* ----------------------------------------
 * SEMANTIC VALUE TYPES SECTION
 * Defines different types of semantic values for grammar symbols
 * ---------------------------------------- */
%union { 
        /* Basic semantic value type with name and node pointer */
        struct var_name { 
			char name[100];           /* Token name/value */
			struct node* nd;          /* Node pointer for AST construction */
		} nd_obj;

        /* Semantic value type with additional type information */
		struct var_name2 { 
			char name[100];           /* Token name/value */
			struct node* nd;          /* Node pointer for AST construction */
			char type[5];             /* Type information (int, float, char) */
		} nd_obj2; 

        /* Semantic value type for conditional statements with label information */
		struct var_name3 {
			char name[100];           /* Token name/value */
			struct node* nd;          /* Node pointer for AST construction */
			char if_body[5];          /* Label for if-body in intermediate code */
			char else_body[5];        /* Label for else-body in intermediate code */
		} nd_obj3;
	} 

/* ----------------------------------------
 * TOKEN DECLARATIONS SECTION
 * Defines tokens returned by lexical analyzer
 * ---------------------------------------- */
%token VOID /* Token for void type */
/* Tokens with semantic value type nd_obj */
%token <nd_obj> CHARACTER PRINTFF SCANFF INT FLOAT CHAR FOR IF ELSE TRUE FALSE NUMBER FLOAT_NUM ID LE GE EQ NE GT LT AND OR STR ADD MULTIPLY DIVIDE SUBTRACT UNARY INCLUDE RETURN 

/* ----------------------------------------
 * NONTERMINAL TYPE DECLARATIONS
 * Associates nonterminals with semantic value types
 * ---------------------------------------- */
%type <nd_obj> headers main body return datatype statement arithmetic relop program else /* Basic nonterminals */
%type <nd_obj2> init value expression /* Nonterminals with type information */
%type <nd_obj3> condition /* Nonterminals for conditionals with label information */

%%
/* ========================================
 * GRAMMAR RULES SECTION
 * Defines the syntax of the language
 * ======================================== */

/* Top-level program structure */
program: headers main '(' ')' '{' body return '}' { 
    /* Create AST for main function by connecting body and return */
    $2.nd = mknode($6.nd, $7.nd, "main"); 
    /* Create program node with headers and main function */
    $$.nd = mknode($1.nd, $2.nd, "program"); 
    /* Store root of AST */
	head = $$.nd;
} 
;

/* Header includes - supports multiple headers */
headers: headers headers { 
    /* Create node for multiple headers */
    $$.nd = mknode($1.nd, $2.nd, "headers"); 
}
| INCLUDE { 
    /* Add include to symbol table as Header */
    add('H'); 
} { 
    /* Create leaf node for include statement */
    $$.nd = mknode(NULL, NULL, $1.name); 
}
;

/* Main function declaration */
main: datatype ID { 
    /* Add main function to symbol table */
    add('F'); 
}
;

/* Data type declarations */
datatype: INT { 
    /* Record that we're processing int type */
    insert_type(); 
}
| FLOAT { 
    /* Record that we're processing float type */
    insert_type(); 
}
| CHAR { 
    /* Record that we're processing char type */
    insert_type(); 
}
| VOID { 
    /* Record that we're processing void type */
    insert_type(); 
}
;

/* Body contains statements, control structures, and function calls */
body: FOR { 
    /* Add FOR keyword to symbol table */
    add('K'); 
    /* Mark that we're processing a for loop */
    is_for = 1; 
} '(' statement ';' condition ';' statement ')' '{' body '}' { 
    /* Create AST for the condition part of for loop (combining condition and update) */
	struct node *temp = mknode($6.nd, $8.nd, "CONDITION"); 
    /* Connect initialization with condition */
	struct node *temp2 = mknode($4.nd, temp, "CONDITION"); 
    /* Create for loop node with conditions and body */
	$$.nd = mknode(temp2, $11.nd, $1.name); 
    
    /* Generate intermediate code for for loop */
	sprintf(icg[ic_idx++], buff);  /* Add update statement from buffer */
	sprintf(icg[ic_idx++], "JUMP to %s\n", $6.if_body);  /* Jump back to condition check */
	sprintf(icg[ic_idx++], "\nLABEL %s:\n", $6.else_body);  /* Exit label for loop */
}
| IF { 
    /* Add IF keyword to symbol table */
    add('K'); 
    /* Mark that we're not processing a for loop */
    is_for = 0; 
} '(' condition ')' { 
    /* Generate intermediate code for if true label */
    sprintf(icg[ic_idx++], "\nLABEL %s:\n", $4.if_body); 
} '{' body '}' { 
    /* Generate intermediate code for else label */
    sprintf(icg[ic_idx++], "\nLABEL %s:\n", $4.else_body); 
} else { 
    /* Create AST for if part (condition and if-body) */
	struct node *iff = mknode($4.nd, $8.nd, $1.name); 
    /* Create if-else node connecting if part with else part */
	$$.nd = mknode(iff, $11.nd, "if-else"); 
    /* Generate code to skip to next statement after if-else */
	sprintf(icg[ic_idx++], "GOTO next\n");
}
| statement ';' { 
    /* Pass up the statement node */
    $$.nd = $1.nd; 
}
| body body { 
    /* Connect multiple body statements */
    $$.nd = mknode($1.nd, $2.nd, "statements"); 
}
| PRINTFF { 
    /* Add printf to symbol table as keyword */
    add('K'); 
} '(' STR ')' ';' { 
    /* Create leaf node for printf */
    $$.nd = mknode(NULL, NULL, "printf"); 
}
| SCANFF { 
    /* Add scanf to symbol table as keyword */
    add('K'); 
} '(' STR ',' '&' ID ')' ';' { 
    /* Create leaf node for scanf */
    $$.nd = mknode(NULL, NULL, "scanf"); 
}
;

/* Else clause of an if-else statement */
else: ELSE { 
    /* Add ELSE keyword to symbol table */
    add('K'); 
} '{' body '}' { 
    /* Create node for else body */
    $$.nd = mknode(NULL, $4.nd, $1.name); 
}
| { 
    /* Empty else clause (just if without else) */
    $$.nd = NULL; 
}
;

/* Condition expressions for if statements and loops */
condition: value relop value { 
    /* Create AST node for relational operation */
	$$.nd = mknode($1.nd, $3.nd, $2.name); 
    
    /* Generate different intermediate code for for-loops vs if-statements */
	if(is_for) {
	    /* For loop condition handling */
		sprintf($$.if_body, "L%d", label++);  /* Label for loop body */
		sprintf(icg[ic_idx++], "\nLABEL %s:\n", $$.if_body);  /* Generate label for condition check */
		sprintf(icg[ic_idx++], "\nif NOT (%s %s %s) GOTO L%d\n", $1.name, $2.name, $3.name, label);  /* Exit loop if condition fails */
		sprintf($$.else_body, "L%d", label++);  /* Label for loop exit */
	} else {
	    /* If statement condition handling */
		sprintf(icg[ic_idx++], "\nif (%s %s %s) GOTO L%d else GOTO L%d\n", $1.name, $2.name, $3.name, label, label+1);  /* Branch based on condition */
		sprintf($$.if_body, "L%d", label++);  /* Label for if-true block */
		sprintf($$.else_body, "L%d", label++);  /* Label for else block */
	}
}
| TRUE { 
    /* Handle TRUE constant in conditions */
    add('K'); 
    $$.nd = NULL; 
}
| FALSE { 
    /* Handle FALSE constant in conditions */
    add('K'); 
    $$.nd = NULL; 
}
| { 
    /* Empty condition (always true) */
    $$.nd = NULL; 
}
;

/* Statements - Variable declarations, assignments, and operations */
statement: datatype ID { 
    /* Add variable to symbol table */
    add('V'); 
} init { 
    /* Create leaf node for identifier */
	$2.nd = mknode(NULL, NULL, $2.name);
	
	/* Check if types match between declared type and initialization */
	int t = check_types($1.name, $4.type);
	
	/* Handle type conversions for variable declarations with initialization */
	if(t>0) { 
		if(t == 1) {
		    /* Convert float to int */
			struct node *temp = mknode(NULL, $4.nd, "floattoint"); 
			$$.nd = mknode($2.nd, temp, "declaration"); 
		} 
		else if(t == 2) { 
		    /* Convert int to float */
			struct node *temp = mknode(NULL, $4.nd, "inttofloat"); 
			$$.nd = mknode($2.nd, temp, "declaration"); 
		} 
		else if(t == 3) { 
		    /* Convert char to int */
			struct node *temp = mknode(NULL, $4.nd, "chartoint"); 
			$$.nd = mknode($2.nd, temp, "declaration"); 
		} 
		else if(t == 4) { 
		    /* Convert int to char */
			struct node *temp = mknode(NULL, $4.nd, "inttochar"); 
			$$.nd = mknode($2.nd, temp, "declaration"); 
		} 
		else if(t == 5) { 
		    /* Convert char to float */
			struct node *temp = mknode(NULL, $4.nd, "chartofloat"); 
			$$.nd = mknode($2.nd, temp, "declaration"); 
		} 
		else {
		    /* Convert float to char */
			struct node *temp = mknode(NULL, $4.nd, "floattochar"); 
			$$.nd = mknode($2.nd, temp, "declaration"); 
		}
	} 
	else { 
	    /* No type conversion needed */
		$$.nd = mknode($2.nd, $4.nd, "declaration"); 
	}
	
	/* Generate intermediate code for variable declaration */
	sprintf(icg[ic_idx++], "%s = %s\n", $2.name, $4.name);
}
/* Variable assignment statement */
| ID { 
    /* Verify that variable is declared */
    check_declaration($1.name); 
} '=' expression {
    /* Create leaf node for identifier */
	$1.nd = mknode(NULL, NULL, $1.name); 
	
	/* Get the type of identifier from symbol table */
	char *id_type = get_type($1.name); 
	
	/* Handle type conversions for assignments if types don't match */
	if(strcmp(id_type, $4.type)) {
		if(!strcmp(id_type, "int")) {
			if(!strcmp($4.type, "float")){
			    /* Convert float expression to int for assignment */
				struct node *temp = mknode(NULL, $4.nd, "floattoint");
				$$.nd = mknode($1.nd, temp, "="); 
			}
			else{
			    /* Convert char expression to int for assignment */
				struct node *temp = mknode(NULL, $4.nd, "chartoint");
				$$.nd = mknode($1.nd, temp, "="); 
			}
		}
		else if(!strcmp(id_type, "float")) {
			if(!strcmp($4.type, "int")){
			    /* Convert int expression to float for assignment */
				struct node *temp = mknode(NULL, $4.nd, "inttofloat");
				$$.nd = mknode($1.nd, temp, "="); 
			}
			else{
			    /* Convert char expression to float for assignment */
				struct node *temp = mknode(NULL, $4.nd, "chartofloat");
				$$.nd = mknode($1.nd, temp, "="); 
			}
		}
		else{
			if(!strcmp($4.type, "int")){
			    /* Convert int expression to char for assignment */
				struct node *temp = mknode(NULL, $4.nd, "inttochar");
				$$.nd = mknode($1.nd, temp, "="); 
			}
			else{
			    /* Convert float expression to char for assignment */
				struct node *temp = mknode(NULL, $4.nd, "floattochar");
				$$.nd = mknode($1.nd, temp, "="); 
			}
		}
	}
	else {
	    /* No type conversion needed for assignment */
		$$.nd = mknode($1.nd, $4.nd, "="); 
	}
	
	/* Generate intermediate code for assignment */
	sprintf(icg[ic_idx++], "%s = %s\n", $1.name, $4.name);
}
/* Relational operation statement */
| ID { 
    /* Check that variable is declared */
    check_declaration($1.name); 
} relop expression { 
    /* Create AST for relational operation */
    $1.nd = mknode(NULL, NULL, $1.name); 
    $$.nd = mknode($1.nd, $4.nd, $3.name); 
}
/* Postfix increment/decrement (ID++) */
| ID { 
    /* Check that variable is declared */
    check_declaration($1.name); 
} UNARY { 
    /* Create AST nodes for ID and operator */
	$1.nd = mknode(NULL, NULL, $1.name); 
	$3.nd = mknode(NULL, NULL, $3.name); 
	$$.nd = mknode($1.nd, $3.nd, "ITERATOR");
	
	/* Generate intermediate code for increment/decrement */
	if(!strcmp($3.name, "++")) {
	    /* Increment operation: ID = ID + 1 */
		sprintf(buff, "t%d = %s + 1\n%s = t%d\n", temp_var, $1.name, $1.name, temp_var++);
	}
	else {
	    /* Decrement operation: ID = ID - 1 (Note: there's a bug here, should be "-1" not "+1") */
		sprintf(buff, "t%d = %s + 1\n%s = t%d\n", temp_var, $1.name, $1.name, temp_var++);
	}
}
/* Prefix increment/decrement (++ID) */
| UNARY ID { 
    /* Check that variable is declared */
	check_declaration($2.name);
	
	/* Create AST nodes for operator and ID */
	$1.nd = mknode(NULL, NULL, $1.name); 
	$2.nd = mknode(NULL, NULL, $2.name); 
	$$.nd = mknode($1.nd, $2.nd, "ITERATOR");
	
	/* Generate intermediate code for increment/decrement */
	if(!strcmp($1.name, "++")) {
	    /* Increment operation: ID = ID + 1 */
		sprintf(buff, "t%d = %s + 1\n%s = t%d\n", temp_var, $2.name, $2.name, temp_var++);
	}
	else {
	    /* Decrement operation: ID = ID - 1 */
		sprintf(buff, "t%d = %s - 1\n%s = t%d\n", temp_var, $2.name, $2.name, temp_var++);
	}
}
;

/* Initialization for variable declarations */
init: '=' value { 
    /* Pass value node up for initialization */
    $$.nd = $2.nd; 
    
    /* Copy type information */
    sprintf($$.type, $2.type); 
    
    /* Copy name for intermediate code generation */
    strcpy($$.name, $2.name); 
}
| { 
    /* Empty initialization (no value provided) */
    sprintf($$.type, "null"); 
    $$.nd = mknode(NULL, NULL, "NULL"); 
    strcpy($$.name, "NULL"); 
}
;

/* Expressions for arithmetic operations */
expression: expression arithmetic expression { 
    /* Check if both operand types match */
	if(!strcmp($1.type, $3.type)) {
	    /* Same type - no conversion needed */
		sprintf($$.type, $1.type);
		$$.nd = mknode($1.nd, $3.nd, $2.name); 
	}
	else {
	    /* Type conversion needed for mixed-type expressions */
		if(!strcmp($1.type, "int") && !strcmp($3.type, "float")) {
		    /* Convert int to float for int+float operation */
			struct node *temp = mknode(NULL, $1.nd, "inttofloat");
			sprintf($$.type, $3.type);
			$$.nd = mknode(temp, $3.nd, $2.name);
		}
		else if(!strcmp($1.type, "float") && !strcmp($3.type, "int")) {
		    /* Convert int to float for float+int operation */
			struct node *temp = mknode(NULL, $3.nd, "inttofloat");
			sprintf($$.type, $1.type);
			$$.nd = mknode($1.nd, temp, $2.name);
		}
		else if(!strcmp($1.type, "int") && !strcmp($3.type, "char")) {
		    /* Convert char to int for int+char operation */
			struct node *temp = mknode(NULL, $3.nd, "chartoint");
			sprintf($$.type, $1.type);
			$$.nd = mknode($1.nd, temp, $2.name);
		}
		else if(!strcmp($1.type, "char") && !strcmp($3.type, "int")) {
		    /* Convert char to int for char+int operation */
			struct node *temp = mknode(NULL, $1.nd, "chartoint");
			sprintf($$.type, $3.type);
			$$.nd = mknode(temp, $3.nd, $2.name);
		}
		else if(!strcmp($1.type, "float") && !strcmp($3.type, "char")) {
		    /* Convert char to float for float+char operation */
			struct node *temp = mknode(NULL, $3.nd, "chartofloat");
			sprintf($$.type, $1.type);
			$$.nd = mknode($1.nd, temp, $2.name);
		}
		else {
		    /* Convert char to float for char+float operation */
			struct node *temp = mknode(NULL, $1.nd, "chartofloat");
			sprintf($$.type, $3.type);
			$$.nd = mknode(temp, $3.nd, $2.name);
		}
	}
	
	/* Create temporary variable name for intermediate code */
	sprintf($$.name, "t%d", temp_var);
	temp_var++;
	
	/* Generate intermediate code for arithmetic operation */
	sprintf(icg[ic_idx++], "%s = %s %s %s\n", $$.name, $1.name, $2.name, $3.name);
}
| value { 
    /* Single value expression - just pass it up */
    strcpy($$.name, $1.name); 
    sprintf($$.type, $1.type); 
    $$.nd = $1.nd; 
}
;

/* Arithmetic operators */
arithmetic: ADD      /* Addition operator + */
| SUBTRACT          /* Subtraction operator - */
| MULTIPLY         /* Multiplication operator * */
| DIVIDE           /* Division operator / */
;

/* Relational operators for conditions */
relop: LT           /* Less than < */
| GT               /* Greater than > */
| LE               /* Less than or equal <= */
| GE               /* Greater than or equal >= */
| EQ               /* Equal to == */
| NE               /* Not equal != */
;

/* Values - numeric constants, variables, etc. */
value: NUMBER { 
    /* Integer constant */
    strcpy($$.name, $1.name); 
    sprintf($$.type, "int"); 
    /* Add to symbol table as Constant */
    add('C'); 
    /* Create leaf node in AST */
    $$.nd = mknode(NULL, NULL, $1.name); 
}
| FLOAT_NUM { 
    /* Floating point constant */
    strcpy($$.name, $1.name); 
    sprintf($$.type, "float"); 
    /* Add to symbol table as Constant */
    add('C'); 
    /* Create leaf node in AST */
    $$.nd = mknode(NULL, NULL, $1.name); 
}
| CHARACTER { 
    /* Character constant */
    strcpy($$.name, $1.name); 
    sprintf($$.type, "char"); 
    /* Add to symbol table as Constant */
    add('C'); 
    /* Create leaf node in AST */
    $$.nd = mknode(NULL, NULL, $1.name); 
}
| ID { 
    /* Variable reference */
    strcpy($$.name, $1.name); 
    /* Get variable type from symbol table */
    char *id_type = get_type($1.name); 
    sprintf($$.type, id_type); 
    /* Verify that variable is declared */
    check_declaration($1.name); 
    /* Create leaf node in AST */
    $$.nd = mknode(NULL, NULL, $1.name); 
}
;

/* Return statement */
return: RETURN { 
    /* Add return as Keyword */
    add('K'); 
} value ';' { 
    /* Check if return type matches function type */
    check_return_type($3.name); 
    /* Create AST for return statement */
    $1.nd = mknode(NULL, NULL, "return"); 
    $$.nd = mknode($1.nd, $3.nd, "RETURN"); 
}
| { 
    /* Empty return (void) */
    $$.nd = NULL; 
}
;

%%

// Declare the output file as a global variable so yyerror can access it
FILE *output_file;

int main() {
    // Open output.txt file for storing all output
    output_file = fopen("output.txt", "w");
    if (output_file == NULL) {
        printf("Error opening output.txt file!\n");
        return 1;
    }
    
    // Parse input and check for syntax errors
    int parse_result = yyparse();
    
    // Helper function to print to both stdout and the output file
    #define PRINT_BOTH(fmt, ...) do { \
        printf(fmt, ##__VA_ARGS__); \
        fprintf(output_file, fmt, ##__VA_ARGS__); \
    } while(0)
    
    // If there were syntax or semantic errors, exit early
    if (parse_result != 0 || sem_errors > 0) {
        PRINT_BOTH("\nCompilation terminated due to syntax or semantic errors.\n");
        fclose(output_file);
        return 1;
    }
    
    // Release memory that we don't need anymore
    int i;
    for(i=0; i<count; i++) {
        free(symbol_table[i].id_name);
        free(symbol_table[i].type);
    }
    
    // PHASE 1: INTERMEDIATE CODE GENERATION (formerly Phase 4)
    PRINT_BOTH("\n\n");
    PRINT_BOTH("\t\t\t\t\t\t\t   PHASE 1: INTERMEDIATE CODE GENERATION \n\n");
    
    for(int i=0; i<ic_idx; i++){
        PRINT_BOTH("%s", icg[i]);
    }
    
    // PHASE 2: CODE OUTPUT PHASE (formerly Phase 5)
    PRINT_BOTH("\n\n");
    PRINT_BOTH("\t\t\t\t\t\t\t\t PHASE 2: CODE OUTPUT PHASE \n\n");
    
    // Create a pipe to capture compiler output
    FILE *gcc_output = popen("gcc -o program_output input.c 2>&1", "r");
    if (gcc_output == NULL) {
        PRINT_BOTH("Error executing gcc compiler!\n");
        fclose(output_file);
        return 1;
    }
    
    // Read and display compiler output
    char buffer[256];
    while (fgets(buffer, sizeof(buffer), gcc_output) != NULL) {
        PRINT_BOTH("%s", buffer);
    }
    
    pclose(gcc_output);
    
    // If compilation successful, run the program and capture its output
    FILE *prog_output = popen("./program_output 2>&1", "r");
    if (prog_output != NULL) {
        PRINT_BOTH("\n--- Program Output ---\n");
        
        while (fgets(buffer, sizeof(buffer), prog_output) != NULL) {
            PRINT_BOTH("%s", buffer);
        }
        pclose(prog_output);
    }
    
    fclose(output_file);
    printf("\n\nCompiler output saved to output.txt\n\n");
    
    #undef PRINT_BOTH
}

int search(char *type) {
	int i;
	for(i=count-1; i>=0; i--) {
		if(strcmp(symbol_table[i].id_name, type)==0) {
			return -1;
			break;
		}
	}
	return 0;
}

void check_declaration(char *c) {
    q = search(c);
    if(!q) {
        sprintf(errors[sem_errors], "Line %d: Variable \"%s\" not declared before usage!\n", countn+1, c);
		sem_errors++;
    }
}

void check_return_type(char *value) {
	char *main_datatype = get_type("main");
	char *return_datatype = get_type(value);
	if((!strcmp(main_datatype, "int") && !strcmp(return_datatype, "CONST")) || !strcmp(main_datatype, return_datatype)){
		return ;
	}
	else {
		sprintf(errors[sem_errors], "Line %d: Return type mismatch\n", countn+1);
		sem_errors++;
	}
}

int check_types(char *type1, char *type2){
	// declaration with no init
	if(!strcmp(type2, "null"))
		return -1;
	// both datatypes are same
	if(!strcmp(type1, type2))
		return 0;
	// both datatypes are different
	if(!strcmp(type1, "int") && !strcmp(type2, "float"))
		return 1;
	if(!strcmp(type1, "float") && !strcmp(type2, "int"))
		return 2;
	if(!strcmp(type1, "int") && !strcmp(type2, "char"))
		return 3;
	if(!strcmp(type1, "char") && !strcmp(type2, "int"))
		return 4;
	if(!strcmp(type1, "float") && !strcmp(type2, "char"))
		return 5;
	if(!strcmp(type1, "char") && !strcmp(type2, "float"))
		return 6;
}

char *get_type(char *var){
	for(int i=0; i<count; i++) {
		// Handle case of use before declaration
		if(!strcmp(symbol_table[i].id_name, var)) {
			return symbol_table[i].data_type;
		}
	}
}

void add(char c) {
	if(c == 'V'){
		for(int i=0; i<10; i++){
			if(!strcmp(reserved[i], strdup(yytext))){
        		sprintf(errors[sem_errors], "Line %d: Variable name \"%s\" is a reserved keyword!\n", countn+1, yytext);
				sem_errors++;
				return;
			}
		}
	}
    q=search(yytext);
	if(!q) {
		if(c == 'H') {
			symbol_table[count].id_name=strdup(yytext);
			symbol_table[count].data_type=strdup(type);
			symbol_table[count].line_no=countn;
			symbol_table[count].type=strdup("Header");
			count++;
		}
		else if(c == 'K') {
			symbol_table[count].id_name=strdup(yytext);
			symbol_table[count].data_type=strdup("N/A");
			symbol_table[count].line_no=countn;
			symbol_table[count].type=strdup("Keyword\t");
			count++;
		}
		else if(c == 'V') {
			symbol_table[count].id_name=strdup(yytext);
			symbol_table[count].data_type=strdup(type);
			symbol_table[count].line_no=countn;
			symbol_table[count].type=strdup("Variable");
			count++;
		}
		else if(c == 'C') {
			symbol_table[count].id_name=strdup(yytext);
			symbol_table[count].data_type=strdup("CONST");
			symbol_table[count].line_no=countn;
			symbol_table[count].type=strdup("Constant");
			count++;
		}
		else if(c == 'F') {
			symbol_table[count].id_name=strdup(yytext);
			symbol_table[count].data_type=strdup(type);
			symbol_table[count].line_no=countn;
			symbol_table[count].type=strdup("Function");
			count++;
		}
    }
    else if(c == 'V' && q) {
        sprintf(errors[sem_errors], "Line %d: Multiple declarations of \"%s\" not allowed!\n", countn+1, yytext);
		sem_errors++;
    }
}

struct node* mknode(struct node *left, struct node *right, char *token) {	
	struct node *newnode = (struct node *)malloc(sizeof(struct node));
	char *newstr = (char *)malloc(strlen(token)+1);
	strcpy(newstr, token);
	newnode->left = left;
	newnode->right = right;
	newnode->token = newstr;
	return(newnode);
}

void print_tree(struct node* tree) {
	// print_tree_util(tree, 0);
	printf("\n\nInorder traversal of the Parse Tree is: \n\n");
	print_inorder(tree);
}

void print_inorder(struct node *tree) {
	int i;
	if (tree->left) {
		print_inorder(tree->left);
	}
	printf("%s, ", tree->token);
	if (tree->right) {
		print_inorder(tree->right);
	}
}

void print_tree_util(struct node *root, int space) {
    if(root == NULL)
        return;
    space += 7;
    print_tree_util(root->right, space);
    for (int i = 7; i < space; i++)
        printf(" ");
	printf("%s\n", root->token);
    print_tree_util(root->left, space);
}

void insert_type() {
	strcpy(type, yytext);
}

void yyerror(const char* msg) {
    extern FILE *output_file;
    extern int countn;
    fprintf(stderr, "Error on line %d: %s\n", countn+1, msg);
    if (output_file != NULL) {
        fprintf(output_file, "Error on line %d: %s\n", countn+1, msg);
    }
    // Set a global error flag to indicate syntax error
    sem_errors++;
}