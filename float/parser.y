%{
    /* ----------------------------------------
     * C DECLARATIONS SECTION
     * Contains header files, function declarations, and global variables
     * ---------------------------------------- */
    #include<stdio.h>
    #include<string.h>
    #include<stdlib.h>
    #include<ctype.h>
    #include"lex.yy.c"  /* Including the lexer output file */
    
    /* Function declarations for parser operations */
    void yyerror(const char *s);  /* Error handling function */
    int yylex();  /* Lexical analyzer function, automatically generated by flex */
    int yywrap();  /* Called when input is exhausted */
    
    /* Symbol table management functions */
    void add(char);  /* Add symbol to symbol table with specified type */
    void insert_type();  /* Insert type information into symbol table */
    int search(char *);  /* Search symbol table for identifier */
    
    /* Parse tree functions */
	void print_tree(struct node*);  /* Print the entire parse tree */
	void print_tree_util(struct node*, int);  /* Utility function for printing parse tree */
	void print_inorder(struct node *);  /* Print tree nodes in-order */
    
    /* Semantic analysis functions */
    void check_declaration(char *);  /* Check if variable is declared */
	void check_return_type(char *);  /* Check if return type matches function type */
	int check_types(char *, char *);  /* Check compatibility of types */
	char *get_type(char *);  /* Get type of a symbol */
	
	/* Parse tree construction */
	struct node* mknode(struct node *left, struct node *right, char *token);  /* Create a new parse tree node */

    /* ----------------------------------------
     * SYMBOL TABLE STRUCTURE
     * For tracking identifiers and their types
     * ---------------------------------------- */
    struct dataType {
        char * id_name;    /* Name of the identifier */
        char * data_type;  /* Data type (int, float, char, etc.) */
        char * type;       /* Symbol type (Variable, Function, etc.) */
        int line_no;       /* Line number where declared */
	} symbol_table[40];    /* Symbol table with max 40 entries */

    /* ----------------------------------------
     * GLOBAL VARIABLES
     * ---------------------------------------- */
    int count=0;           /* Counter for symbol table entries */
    int q;                 /* Flag for symbol table search results */
	char type[10];         /* Current data type being processed */
    extern int countn;     /* Line counter from lexer */
	struct node *head;     /* Root node of the parse tree */
	int sem_errors=0;      /* Counter for semantic errors */
	int ic_idx=0;          /* Index for intermediate code array */
	int temp_var=0;        /* Counter for temporary variables */
	int label=0;           /* Counter for labels in intermediate code */
	int is_for=0;          /* Flag to mark for loop context */
	char buff[100];        /* Buffer for intermediate code generation */
	char errors[10][100];  /* Array to store error messages */
	
	/* List of reserved keywords */
	char reserved[10][10] = {"int", "float", "char", "void", "if", "else", "for", "main", "return", "include"};
	
	/* Array to store generated intermediate code */
	char icg[50][100];

    /* ----------------------------------------
     * PARSE TREE NODE STRUCTURE
     * Binary tree structure for AST representation
     * ---------------------------------------- */
	struct node { 
		struct node *left;  /* Left child node */
		struct node *right; /* Right child node */
		char *token;        /* Node value/token */
	};

%}

/* ----------------------------------------
 * SEMANTIC VALUE TYPES SECTION
 * Defines different types of semantic values for grammar symbols
 * ---------------------------------------- */
%union { 
        /* Basic semantic value type with name and node pointer */
        struct var_name { 
			char name[100];           /* Token name/value */
			struct node* nd;          /* Node pointer for AST construction */
		} nd_obj;

        /* Semantic value type with additional type information */
		struct var_name2 { 
			char name[100];           /* Token name/value */
			struct node* nd;          /* Node pointer for AST construction */
			char type[5];             /* Type information (int, float, char) */
		} nd_obj2; 

        /* Semantic value type for conditional statements with label information */
		struct var_name3 {
			char name[100];           /* Token name/value */
			struct node* nd;          /* Node pointer for AST construction */
			char if_body[5];          /* Label for if-body in intermediate code */
			char else_body[5];        /* Label for else-body in intermediate code */
		} nd_obj3;
	} 

/* ----------------------------------------
 * TOKEN DECLARATIONS SECTION
 * Defines tokens returned by lexical analyzer
 * ---------------------------------------- */
%token VOID /* Token for void type */
/* Tokens with semantic value type nd_obj */
%token <nd_obj> CHARACTER PRINTFF SCANFF INT FLOAT CHAR FOR IF ELSE TRUE FALSE NUMBER FLOAT_NUM ID LE GE EQ NE GT LT AND OR STR ADD MULTIPLY DIVIDE SUBTRACT UNARY INCLUDE RETURN 

/* ----------------------------------------
 * NONTERMINAL TYPE DECLARATIONS
 * Associates nonterminals with semantic value types
 * ---------------------------------------- */
%type <nd_obj> headers main body return datatype statement arithmetic relop program else /* Basic nonterminals */
%type <nd_obj2> init value expression /* Nonterminals with type information */
%type <nd_obj3> condition /* Nonterminals for conditionals with label information */

%%
/* ========================================
 * GRAMMAR RULES SECTION
 * Defines the syntax of the language
 * ======================================== */

/* Top-level program structure */
program: headers main '(' ')' '{' body return '}' { 
    /* Create AST for main function by connecting body and return */
    $2.nd = mknode($6.nd, $7.nd, "main"); 
    /* Create program node with headers and main function */
    $$.nd = mknode($1.nd, $2.nd, "program"); 
    /* Store root of AST */
	head = $$.nd;
} 
;

/* Header includes - supports multiple headers */
headers: headers headers { 
    /* Create node for multiple headers */
    $$.nd = mknode($1.nd, $2.nd, "headers"); 
}
| INCLUDE { 
    /* Add include to symbol table as Header */
    add('H'); 
} { 
    /* Create leaf node for include statement */
    $$.nd = mknode(NULL, NULL, $1.name); 
}
;

/* Main function declaration */
main: datatype ID { 
    /* Add main function to symbol table */
    add('F'); 
}
;

/* Data type declarations */
datatype: INT { 
    /* Record that we're processing int type */
    insert_type(); 
}
| FLOAT { 
    /* Record that we're processing float type */
    insert_type(); 
}
| CHAR { 
    /* Record that we're processing char type */
    insert_type(); 
}
| VOID { 
    /* Record that we're processing void type */
    insert_type(); 
}
;

/* Body contains statements, control structures, and function calls */
body: FOR { 
    /* Add FOR keyword to symbol table */
    add('K'); 
    /* Mark that we're processing a for loop */
    is_for = 1; 
} '(' statement ';' condition ';' statement ')' '{' body '}' { 
    /* Create AST for the condition part of for loop (combining condition and update) */
	struct node *temp = mknode($6.nd, $8.nd, "CONDITION"); 
    /* Connect initialization with condition */
	struct node *temp2 = mknode($4.nd, temp, "CONDITION"); 
    /* Create for loop node with conditions and body */
	$$.nd = mknode(temp2, $11.nd, $1.name); 
    
    /* Generate intermediate code for for loop */
	sprintf(icg[ic_idx++], buff);  /* Add update statement from buffer */
	sprintf(icg[ic_idx++], "JUMP to %s\n", $6.if_body);  /* Jump back to condition check */
	sprintf(icg[ic_idx++], "\nLABEL %s:\n", $6.else_body);  /* Exit label for loop */
}
| IF { 
    /* Add IF keyword to symbol table */
    add('K'); 
    /* Mark that we're not processing a for loop */
    is_for = 0; 
} '(' condition ')' { 
    /* Generate intermediate code for if true label */
    sprintf(icg[ic_idx++], "\nLABEL %s:\n", $4.if_body); 
} '{' body '}' { 
    /* Generate intermediate code for else label */
    sprintf(icg[ic_idx++], "\nLABEL %s:\n", $4.else_body); 
} else { 
    /* Create AST for if part (condition and if-body) */
	struct node *iff = mknode($4.nd, $8.nd, $1.name); 
    /* Create if-else node connecting if part with else part */
	$$.nd = mknode(iff, $11.nd, "if-else"); 
    /* Generate code to skip to next statement after if-else */
	sprintf(icg[ic_idx++], "GOTO next\n");
}
| statement ';' { 
    /* Pass up the statement node */
    $$.nd = $1.nd; 
}
| body body { 
    /* Connect multiple body statements */
    $$.nd = mknode($1.nd, $2.nd, "statements"); 
}
| PRINTFF { 
    /* Add printf to symbol table as keyword */
    add('K'); 
} '(' STR ')' ';' { 
    /* Create leaf node for printf */
    $$.nd = mknode(NULL, NULL, "printf"); 
}
| SCANFF { 
    /* Add scanf to symbol table as keyword */
    add('K'); 
} '(' STR ',' '&' ID ')' ';' { 
    /* Create leaf node for scanf */
    $$.nd = mknode(NULL, NULL, "scanf"); 
}
;

/* Else clause of an if-else statement */
else: ELSE { 
    /* Add ELSE keyword to symbol table */
    add('K'); 
} '{' body '}' { 
    /* Create node for else body */
    $$.nd = mknode(NULL, $4.nd, $1.name); 
}
| { 
    /* Empty else clause (just if without else) */
    $$.nd = NULL; 
}
;

/* Condition expressions for if statements and loops */
condition: value relop value { 
    /* Create AST node for relational operation */
	$$.nd = mknode($1.nd, $3.nd, $2.name); 
    
    /* Generate different intermediate code for for-loops vs if-statements */
	if(is_for) {
	    /* For loop condition handling */
		sprintf($$.if_body, "L%d", label++);  /* Label for loop body */
		sprintf(icg[ic_idx++], "\nLABEL %s:\n", $$.if_body);  /* Generate label for condition check */
		sprintf(icg[ic_idx++], "\nif NOT (%s %s %s) GOTO L%d\n", $1.name, $2.name, $3.name, label);  /* Exit loop if condition fails */
		sprintf($$.else_body, "L%d", label++);  /* Label for loop exit */
	} else {
	    /* If statement condition handling */
		sprintf(icg[ic_idx++], "\nif (%s %s %s) GOTO L%d else GOTO L%d\n", $1.name, $2.name, $3.name, label, label+1);  /* Branch based on condition */
		sprintf($$.if_body, "L%d", label++);  /* Label for if-true block */
		sprintf($$.else_body, "L%d", label++);  /* Label for else block */
	}
}
| TRUE { 
    /* Handle TRUE constant in conditions */
    add('K'); 
    $$.nd = NULL; 
}
| FALSE { 
    /* Handle FALSE constant in conditions */
    add('K'); 
    $$.nd = NULL; 
}
| { 
    /* Empty condition (always true) */
    $$.nd = NULL; 
}
;

/* Statements - Variable declarations, assignments, and operations */
statement: datatype ID { 
    /* Add variable to symbol table */
    add('V'); 
} init { 
    /* Create leaf node for identifier */
	$2.nd = mknode(NULL, NULL, $2.name);
	
	/* Check if types match between declared type and initialization */
	int t = check_types($1.name, $4.type);
	
	/* Handle type conversions for variable declarations with initialization */
	if(t>0) { 
		if(t == 1) {
		    /* Convert float to int */
			struct node *temp = mknode(NULL, $4.nd, "floattoint"); 
			$$.nd = mknode($2.nd, temp, "declaration"); 
		} 
		else if(t == 2) { 
		    /* Convert int to float */
			struct node *temp = mknode(NULL, $4.nd, "inttofloat"); 
			$$.nd = mknode($2.nd, temp, "declaration"); 
		} 
		else if(t == 3) { 
		    /* Convert char to int */
			struct node *temp = mknode(NULL, $4.nd, "chartoint"); 
			$$.nd = mknode($2.nd, temp, "declaration"); 
		} 
		else if(t == 4) { 
		    /* Convert int to char */
			struct node *temp = mknode(NULL, $4.nd, "inttochar"); 
			$$.nd = mknode($2.nd, temp, "declaration"); 
		} 
		else if(t == 5) { 
		    /* Convert char to float */
			struct node *temp = mknode(NULL, $4.nd, "chartofloat"); 
			$$.nd = mknode($2.nd, temp, "declaration"); 
		} 
		else {
		    /* Convert float to char */
			struct node *temp = mknode(NULL, $4.nd, "floattochar"); 
			$$.nd = mknode($2.nd, temp, "declaration"); 
		}
	} 
	else { 
	    /* No type conversion needed */
		$$.nd = mknode($2.nd, $4.nd, "declaration"); 
	}
	
	/* Generate intermediate code for variable declaration */
	sprintf(icg[ic_idx++], "%s = %s\n", $2.name, $4.name);
}
/* Variable assignment statement */
| ID { 
    /* Verify that variable is declared */
    check_declaration($1.name); 
} '=' expression {
    /* Create leaf node for identifier */
	$1.nd = mknode(NULL, NULL, $1.name); 
	
	/* Get the type of identifier from symbol table */
	char *id_type = get_type($1.name); 
	
	/* Handle type conversions for assignments if types don't match */
	if(strcmp(id_type, $4.type)) {
		if(!strcmp(id_type, "int")) {
			if(!strcmp($4.type, "float")){
			    /* Convert float expression to int for assignment */
				struct node *temp = mknode(NULL, $4.nd, "floattoint");
				$$.nd = mknode($1.nd, temp, "="); 
			}
			else{
			    /* Convert char expression to int for assignment */
				struct node *temp = mknode(NULL, $4.nd, "chartoint");
				$$.nd = mknode($1.nd, temp, "="); 
			}
		}
		else if(!strcmp(id_type, "float")) {
			if(!strcmp($4.type, "int")){
			    /* Convert int expression to float for assignment */
				struct node *temp = mknode(NULL, $4.nd, "inttofloat");
				$$.nd = mknode($1.nd, temp, "="); 
			}
			else{
			    /* Convert char expression to float for assignment */
				struct node *temp = mknode(NULL, $4.nd, "chartofloat");
				$$.nd = mknode($1.nd, temp, "="); 
			}
		}
		else{
			if(!strcmp($4.type, "int")){
			    /* Convert int expression to char for assignment */
				struct node *temp = mknode(NULL, $4.nd, "inttochar");
				$$.nd = mknode($1.nd, temp, "="); 
			}
			else{
			    /* Convert float expression to char for assignment */
				struct node *temp = mknode(NULL, $4.nd, "floattochar");
				$$.nd = mknode($1.nd, temp, "="); 
			}
		}
	}
	else {
	    /* No type conversion needed for assignment */
		$$.nd = mknode($1.nd, $4.nd, "="); 
	}
	
	/* Generate intermediate code for assignment */
	sprintf(icg[ic_idx++], "%s = %s\n", $1.name, $4.name);
}
/* Relational operation statement */
| ID { 
    /* Check that variable is declared */
    check_declaration($1.name); 
} relop expression { 
    /* Create AST for relational operation */
    $1.nd = mknode(NULL, NULL, $1.name); 
    $$.nd = mknode($1.nd, $4.nd, $3.name); 
}
/* Postfix increment/decrement (ID++) */
| ID { 
    /* Check that variable is declared */
    check_declaration($1.name); 
} UNARY { 
    /* Create AST nodes for ID and operator */
	$1.nd = mknode(NULL, NULL, $1.name); 
	$3.nd = mknode(NULL, NULL, $3.name); 
	$$.nd = mknode($1.nd, $3.nd, "ITERATOR");
	
	/* Generate intermediate code for increment/decrement */
	if(!strcmp($3.name, "++")) {
	    /* Increment operation: ID = ID + 1 */
		sprintf(buff, "t%d = %s + 1\n%s = t%d\n", temp_var, $1.name, $1.name, temp_var++);
	}
	else {
	    /* Decrement operation: ID = ID - 1 */
		sprintf(buff, "t%d = %s - 1\n%s = t%d\n", temp_var, $1.name, $1.name, temp_var++);
	}
}
/* Prefix increment/decrement (++ID) */
| UNARY ID { 
    /* Check that variable is declared */
	check_declaration($2.name);
	
	/* Create AST nodes for operator and ID */
	$1.nd = mknode(NULL, NULL, $1.name); 
	$2.nd = mknode(NULL, NULL, $2.name); 
	$$.nd = mknode($1.nd, $2.nd, "ITERATOR");
	
	/* Generate intermediate code for increment/decrement */
	if(!strcmp($1.name, "++")) {
	    /* Increment operation: ID = ID + 1 */
		sprintf(buff, "t%d = %s + 1\n%s = t%d\n", temp_var, $2.name, $2.name, temp_var++);
	}
	else {
	    /* Decrement operation: ID = ID - 1 */
		sprintf(buff, "t%d = %s - 1\n%s = t%d\n", temp_var, $2.name, $2.name, temp_var++);
	}
}
;

/* Initialization for variable declarations */
init: '=' value { 
    /* Pass value node up for initialization */
    $$.nd = $2.nd; 
    
    /* Copy type information */
    sprintf($$.type, $2.type); 
    
    /* Copy name for intermediate code generation */
    strcpy($$.name, $2.name); 
}
| { 
    /* Empty initialization (no value provided) */
    sprintf($$.type, "null"); 
    $$.nd = mknode(NULL, NULL, "NULL"); 
    strcpy($$.name, "NULL"); 
}
;

/* Expressions for arithmetic operations */
expression: expression arithmetic expression { 
    /* Check if both operand types match */
	if(!strcmp($1.type, $3.type)) {
	    /* Same type - no conversion needed */
		sprintf($$.type, $1.type);
		$$.nd = mknode($1.nd, $3.nd, $2.name); 
	}
	else {
	    /* Type conversion needed for mixed-type expressions */
		if(!strcmp($1.type, "int") && !strcmp($3.type, "float")) {
		    /* Convert int to float for int+float operation */
			struct node *temp = mknode(NULL, $1.nd, "inttofloat");
			sprintf($$.type, $3.type);
			$$.nd = mknode(temp, $3.nd, $2.name);
		}
		else if(!strcmp($1.type, "float") && !strcmp($3.type, "int")) {
		    /* Convert int to float for float+int operation */
			struct node *temp = mknode(NULL, $3.nd, "inttofloat");
			sprintf($$.type, $1.type);
			$$.nd = mknode($1.nd, temp, $2.name);
		}
		else if(!strcmp($1.type, "int") && !strcmp($3.type, "char")) {
		    /* Convert char to int for int+char operation */
			struct node *temp = mknode(NULL, $3.nd, "chartoint");
			sprintf($$.type, $1.type);
			$$.nd = mknode($1.nd, temp, $2.name);
		}
		else if(!strcmp($1.type, "char") && !strcmp($3.type, "int")) {
		    /* Convert char to int for char+int operation */
			struct node *temp = mknode(NULL, $1.nd, "chartoint");
			sprintf($$.type, $3.type);
			$$.nd = mknode(temp, $3.nd, $2.name);
		}
		else if(!strcmp($1.type, "float") && !strcmp($3.type, "char")) {
		    /* Convert char to float for float+char operation */
			struct node *temp = mknode(NULL, $3.nd, "chartofloat");
			sprintf($$.type, $1.type);
			$$.nd = mknode($1.nd, temp, $2.name);
		}
		else {
		    /* Convert char to float for char+float operation */
			struct node *temp = mknode(NULL, $1.nd, "chartofloat");
			sprintf($$.type, $3.type);
			$$.nd = mknode(temp, $3.nd, $2.name);
		}
	}
	
	/* Create temporary variable name for intermediate code */
	sprintf($$.name, "t%d", temp_var);
	temp_var++;
	
	/* Generate intermediate code for arithmetic operation */
	sprintf(icg[ic_idx++], "%s = %s %s %s\n", $$.name, $1.name, $2.name, $3.name);
}
| value { 
    /* Single value expression - just pass it up */
    strcpy($$.name, $1.name); 
    sprintf($$.type, $1.type); 
    $$.nd = $1.nd; 
}
;

/* Arithmetic operators */
arithmetic: ADD      /* Addition operator + */
| SUBTRACT          /* Subtraction operator - */
| MULTIPLY         /* Multiplication operator * */
| DIVIDE           /* Division operator / */
;

/* Relational operators for conditions */
relop: LT           /* Less than < */
| GT               /* Greater than > */
| LE               /* Less than or equal <= */
| GE               /* Greater than or equal >= */
| EQ               /* Equal to == */
| NE               /* Not equal != */
;

/* Values - numeric constants, variables, etc. */
value: NUMBER { 
    /* Integer constant */
    strcpy($$.name, $1.name); 
    sprintf($$.type, "int"); 
    /* Add to symbol table as Constant */
    add('C'); 
    /* Create leaf node in AST */
    $$.nd = mknode(NULL, NULL, $1.name); 
}
| FLOAT_NUM { 
    /* Floating point constant */
    strcpy($$.name, $1.name); 
    sprintf($$.type, "float"); 
    /* Add to symbol table as Constant */
    add('C'); 
    /* Create leaf node in AST */
    $$.nd = mknode(NULL, NULL, $1.name); 
}
| CHARACTER { 
    /* Character constant */
    strcpy($$.name, $1.name); 
    sprintf($$.type, "char"); 
    /* Add to symbol table as Constant */
    add('C'); 
    /* Create leaf node in AST */
    $$.nd = mknode(NULL, NULL, $1.name); 
}
| ID { 
    /* Variable reference */
    strcpy($$.name, $1.name); 
    /* Get variable type from symbol table */
    char *id_type = get_type($1.name); 
    sprintf($$.type, id_type); 
    /* Verify that variable is declared */
    check_declaration($1.name); 
    /* Create leaf node in AST */
    $$.nd = mknode(NULL, NULL, $1.name); 
}
;

/* Return statement */
return: RETURN { 
    /* Add return as Keyword */
    add('K'); 
} value ';' { 
    /* Check if return type matches function type */
    check_return_type($3.name); 
    /* Create AST for return statement */
    $1.nd = mknode(NULL, NULL, "return"); 
    $$.nd = mknode($1.nd, $3.nd, "RETURN"); 
}
| { 
    /* Empty return (void) */
    $$.nd = NULL; 
}
;

%%

// Declare the output file as a global variable so yyerror can access it
FILE *output_file;

/* ========================================
 * MAIN FUNCTION
 * Entry point for the compiler
 * ======================================== */
int main() {
    /* Open output.txt file for storing compilation results */
    output_file = fopen("output.txt", "w");
    if (output_file == NULL) {
        printf("Error opening output.txt file!\n");
        return 1;
    }
    
    /* Define macro to print to both stdout and output file simultaneously */
    #define PRINT_BOTH(fmt, ...) do { \
        printf(fmt, ##__VA_ARGS__); \
        fprintf(output_file, fmt, ##__VA_ARGS__); \
    } while(0)
    
    /* Start the parsing process - this will process the entire input file */
    int parse_result = yyparse();
    
    /* Check for syntax or semantic errors */
    if (parse_result != 0 || sem_errors > 0) {
        /* Print error message */
        PRINT_BOTH("\nCompilation terminated due to syntax or semantic errors.\n");
        
        /* Print all semantic errors collected during compilation */
        for (int i = 0; i < sem_errors; i++) {
            PRINT_BOTH("%s", errors[i]);
        }
        
        /* Clean up and exit with error code */
        fclose(output_file);
        return 1;
    }
    
    /* Free memory allocated for symbol table */
    int i;
    for(i=0; i<count; i++) {
        free(symbol_table[i].id_name);
        free(symbol_table[i].type);
    }
    
    /* ----------------------------------------
     * PHASE 1: INTERMEDIATE CODE GENERATION
     * Output the three-address code generated during parsing
     * ---------------------------------------- */
    PRINT_BOTH("\n\n");
    PRINT_BOTH("\t\t\t\t\t\t\t   PHASE 1: INTERMEDIATE CODE GENERATION \n\n");
    
    /* Print all the intermediate code instructions */
    for(int i=0; i<ic_idx; i++){
        PRINT_BOTH("%s", icg[i]);
    }
    
    /* ----------------------------------------
     * PHASE 2: CODE OUTPUT PHASE
     * Compile and run the generated C code
     * ---------------------------------------- */
    PRINT_BOTH("\n\n");
    PRINT_BOTH("\t\t\t\t\t\t\t\t PHASE 2: CODE OUTPUT PHASE \n\n");
    
    /* Use popen to run gcc compiler and capture its output */
    FILE *gcc_output = popen("gcc -o program_output input.c 2>&1", "r");
    if (gcc_output == NULL) {
        PRINT_BOTH("Error executing gcc compiler!\n");
        fclose(output_file);
        return 1;
    }
    
    /* Read and print compiler output line by line */
    char buffer[256];
    while (fgets(buffer, sizeof(buffer), gcc_output) != NULL) {
        PRINT_BOTH("%s", buffer);
    }
    
    /* Close the pipe to the compiler */
    pclose(gcc_output);
    
    /* If compilation succeeded, execute the compiled program */
    FILE *prog_output = popen("./program_output 2>&1", "r");
    if (prog_output != NULL) {
        PRINT_BOTH("\n--- Program Output ---\n");
        
        /* Capture and display program output */
        while (fgets(buffer, sizeof(buffer), prog_output) != NULL) {
            PRINT_BOTH("%s", buffer);
        }
        pclose(prog_output);
    }
    
    /* Close output file and display completion message */
    fclose(output_file);
    printf("\n\nCompiler output saved to output.txt\n\n");
    
    /* Undefine the helper macro */
    #undef PRINT_BOTH
}

/* ========================================
 * SYMBOL TABLE MANAGEMENT FUNCTIONS
 * ======================================== */

/* 
 * Search for an identifier in the symbol table
 * Returns -1 if found, 0 if not found
 * Uses reverse search to find the most recent declaration
 */
int search(char *type) {
	int i;
	/* Search from most recent entry backward */
	for(i=count-1; i>=0; i--) {
		if(strcmp(symbol_table[i].id_name, type)==0) {
			/* Found match - return -1 */
			return -1;
			break;
		}
	}
	/* No match found - return 0 */
	return 0;
}

/* 
 * Verify that a variable has been declared before use
 * Adds an error message if variable not found in symbol table
 */
void check_declaration(char *c) {
    /* Search for the variable in symbol table */
    q = search(c);
    if(!q) {
        /* Variable not found - add error message */
        sprintf(errors[sem_errors], "Line %d: Variable \"%s\" not declared before usage!\n", countn+1, c);
		sem_errors++;
    }
}

/* ========================================
 * TYPE CHECKING FUNCTIONS
 * ======================================== */

/*
 * Check if return type matches function declaration type
 * Allows int constants to be returned from int functions
 */
void check_return_type(char *value) {
	/* Get the data type of main function */
	char *main_datatype = get_type("main");
	/* Get the data type of return value */
	char *return_datatype = get_type(value);
	
	/* Check if types match - constants can be returned from int functions */
	if((!strcmp(main_datatype, "int") && !strcmp(return_datatype, "CONST")) || 
	   !strcmp(main_datatype, return_datatype)){
		/* Types match - no error */
		return;
	}
	else {
		/* Type mismatch - add error message */
		sprintf(errors[sem_errors], "Line %d: Return type mismatch\n", countn+1);
		sem_errors++;
	}
}

/*
 * Check compatibility of types and determine conversion needed
 * Returns:
 *   -1: No initialization
 *    0: Types match (no conversion needed)
 *    1: float to int conversion
 *    2: int to float conversion
 *    3: char to int conversion
 *    4: int to char conversion
 *    5: char to float conversion
 *    6: float to char conversion
 */
int check_types(char *type1, char *type2){
	/* Case 1: Declaration with no initialization */
	if(!strcmp(type2, "null"))
		return -1;
		
	/* Case 2: Both datatypes are the same */
	if(!strcmp(type1, type2))
		return 0;
		
	/* Case 3: Different datatypes - determine conversion needed */
	if(!strcmp(type1, "int") && !strcmp(type2, "float"))
		return 1;  /* float to int */
		
	if(!strcmp(type1, "float") && !strcmp(type2, "int"))
		return 2;  /* int to float */
		
	if(!strcmp(type1, "int") && !strcmp(type2, "char"))
		return 3;  /* char to int */
		
	if(!strcmp(type1, "char") && !strcmp(type2, "int"))
		return 4;  /* int to char */
		
	if(!strcmp(type1, "float") && !strcmp(type2, "char"))
		return 5;  /* char to float */
		
	if(!strcmp(type1, "char") && !strcmp(type2, "float"))
		return 6;  /* float to char */
}

/*
 * Get the data type of a variable from symbol table
 * Returns "undefined" if variable is not found
 */
char *get_type(char *var){
	/* Linear search through symbol table */
	for(int i=0; i<count; i++) {
		/* Look for matching identifier */
		if(!strcmp(symbol_table[i].id_name, var)) {
			/* Return its data type */
			return symbol_table[i].data_type;
		}
	}
	
	/* If the variable is not found, return "undefined" to avoid undefined behavior */
	return "undefined";
}

/*
 * Add symbol to symbol table with specified category
 * c: 'V' - Variable, 'F' - Function, 'H' - Header, 'K' - Keyword, 'C' - Constant
 */
void add(char c) {
	/* For variables, check if name is a reserved keyword */
	if(c == 'V'){
		for(int i=0; i<10; i++){
			if(!strcmp(reserved[i], strdup(yytext))){
        		/* Can't use reserved keyword as variable name */
        		sprintf(errors[sem_errors], "Line %d: Variable name \"%s\" is a reserved keyword!\n", countn+1, yytext);
				sem_errors++;
				return;
			}
		}
	}
	
	/* Check if symbol already exists in table */
    q = search(yytext);
	if(!q) {
		/* Symbol doesn't exist - add it based on category */
		if(c == 'H') {
			/* Add header include */
			symbol_table[count].id_name=strdup(yytext);
			symbol_table[count].data_type=strdup(type);
			symbol_table[count].line_no=countn;
			symbol_table[count].type=strdup("Header");
			count++;
		}
		else if(c == 'K') {
			/* Add keyword */
			symbol_table[count].id_name=strdup(yytext);
			symbol_table[count].data_type=strdup("N/A");
			symbol_table[count].line_no=countn;
			symbol_table[count].type=strdup("Keyword\t");
			count++;
		}
		else if(c == 'V') {
			/* Add variable */
			symbol_table[count].id_name=strdup(yytext);
			symbol_table[count].data_type=strdup(type);
			symbol_table[count].line_no=countn;
			symbol_table[count].type=strdup("Variable");
			count++;
		}
		else if(c == 'C') {
			/* Add constant */
			symbol_table[count].id_name=strdup(yytext);
			symbol_table[count].data_type=strdup("CONST");
			symbol_table[count].line_no=countn;
			symbol_table[count].type=strdup("Constant");
			count++;
		}
		else if(c == 'F') {
			/* Add function */
			symbol_table[count].id_name=strdup(yytext);
			symbol_table[count].data_type=strdup(type);
			symbol_table[count].line_no=countn;
			symbol_table[count].type=strdup("Function");
			count++;
		}
    }
    else if(c == 'V' && q) {
    	/* Variable already declared - error */
        sprintf(errors[sem_errors], "Line %d: Multiple declarations of \"%s\" not allowed!\n", countn+1, yytext);
		sem_errors++;
    }
}

/* ========================================
 * ABSTRACT SYNTAX TREE FUNCTIONS
 * ======================================== */

/*
 * Create a new node for the abstract syntax tree
 * left: Pointer to left child node
 * right: Pointer to right child node
 * token: Value/token for this node
 */
struct node* mknode(struct node *left, struct node *right, char *token) {	
	/* Allocate memory for new node */
	struct node *newnode = (struct node *)malloc(sizeof(struct node));
	
	/* Copy token string to new memory */
	char *newstr = (char *)malloc(strlen(token)+1);
	strcpy(newstr, token);
	
	/* Set node properties */
	newnode->left = left;
	newnode->right = right;
	newnode->token = newstr;
	
	/* Return the newly created node */
	return(newnode);
}

/* 
 * Print the entire abstract syntax tree
 * tree: Root node of the tree to print
 */
void print_tree(struct node* tree) {
	// print_tree_util(tree, 0);  // Alternate visualization (commented out)
	printf("\n\nInorder traversal of the Parse Tree is: \n\n");
	print_inorder(tree);
}

/*
 * Print tree nodes in inorder traversal (left-root-right)
 * tree: Current node being processed
 */
void print_inorder(struct node *tree) {
	/* Process left subtree first */
	if (tree->left) {
		print_inorder(tree->left);
	}
	
	/* Print current node */
	printf("%s, ", tree->token);
	
	/* Process right subtree last */
	if (tree->right) {
		print_inorder(tree->right);
	}
}

/*
 * Print tree with visual indentation
 * root: Current node being processed
 * space: Current indentation level
 */
void print_tree_util(struct node *root, int space) {
    /* Base case */
    if(root == NULL)
        return;
        
    /* Increase distance between levels */
    space += 7;
    
    /* Process right child first (will appear at top) */
    print_tree_util(root->right, space);
    
    /* Print current node with indentation */
    for (int i = 7; i < space; i++)
        printf(" ");
	printf("%s\n", root->token);
	
	/* Process left child */
    print_tree_util(root->left, space);
}

/*
 * Copy current token text to global type variable
 * Used in datatype declarations to record current type
 */
void insert_type() {
	strcpy(type, yytext);
}

/*
 * Handle syntax error reporting
 * msg: Error message from parser
 */
void yyerror(const char* msg) {
    /* Print error message with line number to stderr */
    fprintf(stderr, "Error on line %d: %s\n", countn+1, msg);
    
    /* If output file is open, also write error there */
    if (output_file != NULL) {
        fprintf(output_file, "Error on line %d: %s\n", countn+1, msg);
    }
    
    /* Increment semantic error count to indicate parsing failed */
    sem_errors++;
}

